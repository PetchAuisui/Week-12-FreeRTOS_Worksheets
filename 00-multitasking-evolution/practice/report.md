# บันทึกผลการทดลอง
## Lab1-single-vs-multi
### Result
#### Part 1: Single Task System
<img width="1919" height="1079" alt="image" src="https://github.com/user-attachments/assets/54eacc75-36e8-4401-bf18-d8365122efc1" />

#### Part 2: Multitasking System
<img width="1915" height="1070" alt="image" src="https://github.com/user-attachments/assets/5d68b13a-7ee2-4420-8976-e5415fb7e050" />

### คำถามสำหรับวิเคราะห์
1. ความแตกต่างในการตอบสนองปุ่มระหว่างทั้งสองระบบคืออะไร?
- Single Task System: เมื่อกดปุ่ม ระบบจะตอบสนองช้า เพราะต้องรอให้งานที่ทำอยู่เสร็จถึงจะไปทำงานใหม่ได้
- Multitasking System: เมื่อกดปุ่ม ระบบตอบสนองได้เร็วกว่า เพราะระบบแบ่งเวลา (time slicing) ให้แต่ละงาน ทำให้สามารถสลับไปตอบสนองปุ่มได้ทันทีแม้จะมีงานอื่นกำลังทำอยู่
2. ใน Single Task System งานไหนที่ทำให้การตอบสนองล่าช้า?
- งานที่ กินเวลานาน (long-running task) เช่น การประมวลผลที่ใช้ CPU มาก, การคำนวณที่ยาว, หรือการรอ I/O ที่นาน จะทำให้ระบบไม่สามารถตอบสนองปุ่มได้ทันท่วงที
- สรุปคือ งานหลักที่รันอยู่ จะเป็นตัวบล็อกการตอบสนองของปุ่ม
3. ข้อดีของ Multitasking System ที่สังเกตได้คืออะไร?
- ตอบสนองเร็วกว่า ต่อการกดปุ่มหรือ input อื่น ๆ
- ทำงานหลายอย่างพร้อมกัน ได้ เช่น โหลดข้อมูลไปด้วย และยังตอบสนองผู้ใช้ได้
- ใช้งานลื่นไหล กว่า แม้งานใหญ่ยังไม่เสร็จ แต่ผู้ใช้ยังโต้ตอบกับระบบได้
4.มีข้อเสียของ Multitasking System ที่สังเกตได้หรือไม่?
- อาจมี overhead จากการสลับงาน (context switching) ทำให้การใช้ทรัพยากรไม่เต็มประสิทธิภาพ
- ถ้ามีงานเยอะเกินไป ระบบอาจเกิด แย่ง CPU/Memory ทำให้ช้าลง
- การจัดการยากกว่า single task เพราะต้องคุมลำดับความสำคัญ (priority) และป้องกันปัญหา deadlock/ starvation

## Lab 2: Time-Sharing Implementation
### Result 
#### Time-Sharing with Variable Workloads
<img width="1919" height="1079" alt="image" src="https://github.com/user-attachments/assets/a978752d-f3ce-42b3-a63f-2a21f544fa24" />

#### การวิเคราะห์ปัญหา
<img width="1919" height="1079" alt="image" src="https://github.com/user-attachments/assets/a8140e7b-7dc6-4b08-ac8a-e9f772907e68" />

### คำถามสำหรับวิเคราะห์
1. Time slice ขนาดไหนให้ประสิทธิภาพดีที่สุด? เพราะอะไร?
- ขนาดที่ พอดี ไม่สั้นเกินไปและไม่ยาวเกินไป (มักอยู่ระดับ 10–100 ms)
- เพราะ:
  - สั้นพอ ที่ผู้ใช้จะรู้สึกว่าระบบตอบสนองเร็ว (interactive)
  - ยาวพอ ที่แต่ละงานจะทำงานได้จริงก่อนถูกสลับออก (ลด context switching overhead)
2. ปัญหาอะไรที่เกิดขึ้นเมื่อ time slice สั้นเกินไป?
- Context switching บ่อยเกินไป → CPU เสียเวลาเปลี่ยนงานแทนที่จะประมวลผลงานจริง
- ทำให้ ประสิทธิภาพรวมลดลง เพราะ overhead สูง
- งานที่ต้องการ CPU ต่อเนื่อง (CPU-bound) จะช้าลงมาก
3. ปัญหาอะไรที่เกิดขึ้นเมื่อ time slice ยาวเกินไป?
- งานที่รันอยู่จะ ผูกขาด CPU นานเกินไป → งานอื่นต้องรอนาน
- ส่งผลให้ การตอบสนองของระบบแย่ลง (เช่น input จากผู้ใช้หน่วง)
เหมือนระบบกลับไปใกล้ single task มากขึ้น
4. Context switching overhead คิดเป็นกี่เปอร์เซ็นต์ของเวลาทั้งหมด?
- ขึ้นอยู่กับสถาปัตยกรรมและ workload แต่โดยทั่วไปอยู่ที่ 1–5% ของเวลาทั้งหมด
- ถ้า time slice สั้นเกินไป overhead อาจพุ่งถึง 10%+
- ระบบจริง (เช่น Linux) จึงเลือกค่า time slice ที่สมดุล เช่น ~10–20ms
5. งานไหนที่ได้รับผลกระทบมากที่สุดจากการ time-sharing?
-  งาน CPU-bound (ต้องใช้ CPU ต่อเนื่อง) → โดนสลับออกก่อนเสร็จ ต้องรอรอบใหม่เสมอ
-  งาน Real-time (ต้องตอบสนองทันเวลา) → เสี่ยงพลาด deadline ถ้า time slice ยาวไป
-  ส่วน งาน I/O-bound (รอ I/O บ่อย) มักไม่ค่อยได้รับผลกระทบมาก เพราะมันยอมปล่อย CPU เองอยู่แล้ว

## Lab 3: Cooperative vs Preemptive Comparison
### Result
#### Cooperative Multitasking
<img width="1919" height="1079" alt="Screenshot 2025-10-01 200813" src="https://github.com/user-attachments/assets/05034ab1-449c-4702-9a91-70dab748ce80" />

#### Preemptive Multitasking
<img width="1919" height="1079" alt="image" src="https://github.com/user-attachments/assets/290bb520-d02d-4ead-a845-59d35694a35d" />

### คำถามสำหรับวิเคราะห์
1. ระบบไหนมีเวลาตอบสนองดีกว่า? เพราะอะไร?
- Preemptive ดีกว่า โดยเฉพาะงานฉุกเฉินหรือสำคัญ เพราะงาน priority สูงสามารถแย่ง CPU ได้ทันที (หรือภายในช่วง tick/ช่วงปิดอินเทอร์รัพท์สั้น ๆ) โดยไม่ต้องรอให้งานอื่นยอมปล่อยเอง
2. ข้อดีของ Cooperative Multitasking คืออะไร?
- โอเวอร์เฮดต่ำ: สลับบริบทน้อย เพราะสลับเฉพาะจุดที่ตั้งใจ `yield/delay`
- คาดเดาพฤติกรรมง่าย: ลูปการทำงานเป็นเส้นตรง ควบคุมจุดสลับเอง ดีบักง่าย
- ลดโอกาส race กลางคัน: ไม่โดนพรีเอมป์กลางโค้ดบ่อย ทำให้แชร์ตัวแปรง่ายขึ้น (แม้ยังต้องระวัง)
3. ข้อเสียของ Cooperative Multitasking คืออะไร?
- Latency แย่ถ้างานไม่ยอม yield: งานเดียวลากยาว ระบบอื่นต้องรอ เหตุฉุกเฉินมาช้า
- ความยุติธรรมและความตอบสนองขึ้นกับวินัยของแต่ละงาน: ลืม `vTaskDelay()` หรือวางจุด yield น้อยเกินไป ระบบจะหน่วง
- การันตี deadline ยาก: เวลาตอบสนองกรณีแย่สุดขึ้นกับจุด yield ของทุกงาน
4. ในสถานการณ์ใดที่ Cooperative จะดีกว่า Preemptive?
- แอปเรียบง่าย งานไม่ซับซ้อน และเชื่อใจได้ว่าจะ yield บ่อยพอ
- ต้องการโอเวอร์เฮดต่ำหรือประหยัดพลังงาน และยอมรับ latency ได้
- งานลำดับชัดเจน (เช่น state machine ง่าย ๆ) ที่คุมจังหวะพักเองอย่างตั้งใจ
5. เหตุใด Preemptive จึงเหมาะสำหรับ Real-time systems?
- ตอบสนองตามลำดับความสำคัญได้จริง: งานสำคัญสูงแทรกขึ้นทันที จึงมีขอบบนของ latency ชัดเจน (จำกัดด้วย tick/ช่วงปิด IRQ)
- ป้องกันงานที่ทำงานผิดพลาดไม่ให้ลากทั้งระบบ: งาน priority ต่ำถูกแย่ง CPU ได้
- รับมือเหตุการณ์ภายนอกแบบกะทันหัน: จัดลำดับด้วย priority-based scheduling ได้ถูกต้อง แม่นยำ
  - ต้องแลกกับโอเวอร์เฮดสูงขึ้นและซิงโครไนซ์ซับซ้อนกว่า (ระวัง priority inversion และใช้ priority inheritance เมื่อเหมาะสม)


